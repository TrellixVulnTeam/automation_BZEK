from functools import wraps
from math import isnan
from time import sleep
from abc import ABC, abstractmethod
import pyvisa
import atexit
import os

GPIB_NO = 0

type_to_address = {
    'gpib': f'GPIB{GPIB_NO}',
    'lan': 'TCPIP',
    'usb': 'USB',
    'serial': None
    }

def reject_nan(func):
    @wraps(func)
    def wrapped(*args, **kwargs):
        for _ in range(10):
            response = func(*args, **kwargs)
            if not isnan(response):
                return response
            sleep(0.2)
        return None
    return wrapped

class Equipment(ABC):
    def __init__(self, address, comm_type='gpib', timeout=10000):
        rm = pyvisa.ResourceManager()
        self.address = f'{type_to_address[comm_type]}::{address}'
        self.timeout = timeout
        try:
            self.device = rm.open_resource(self.address)
            self.device.timeout = self.timeout
            atexit.register(self.cleanup)
        except Exception as e:
            raise pyvisa.VisaIOError(e)

        self._id = 0

    def __repr__(self):
        return (f'{self.__class__.__name__}'
                 '(address={self.address}, timeout={self.timeout})')

    @abstractmethod
    def cleanup(self):
        pass

    @property
    def id(self):
        self._id = self.write('*IDN?')
        return self._id

    def close(self):
        self.device.close()

    def write(self, command):
        response = None
        try:
            if "?" in command:
                response = self.device.query(command).strip()
            else:
                self.device.write(command)
        except Exception as e:
            raise pyvisa.VisaIOError(e)

        return response

class ACSource(Equipment):
    def __init__(self, address, comm_type='gpib', timeout=10000):
        super().__init__(address, comm_type, timeout)

        self._voltage = 0
        self._frequency = 0
        self._coupling = 'AC'

    def turn_on(self, phase=None):
        if self._coupling == 'AC':
            self.write(f'VOLT {self._voltage}')
            self.write('OUTP:COUP AC')
            self.write('VOLT:OFFS 0')
            # self.write('TRIF:SYNC:PHAS 270')
            # self.write(f'PHAS {self.phase}')
        elif self._coupling == 'DC':
            self.write('VOLT 0')
            self.write('OUTP:COUP DC')
            self.write(f'VOLT:OFFS {self._voltage}')
            # self.write('TRIF:SYNC:PHAS 270')
            # self.write(f'PHAS {self.phase}')
        self.write('OUTP ON')

    def turn_off(self):
        self.write('OUTP OFF')

    @property
    def voltage(self):
        return self._voltage

    @property
    def frequency(self):
        return self._frequency
    
    @property
    def coupling(self):
        return self._coupling

    @voltage.setter
    def voltage(self, voltage):
        self._voltage = voltage

    @frequency.setter
    def frequency(self, frequency):
        self._frequency = frequency
        self.write(f'FREQ {self._frequency}')

    @coupling.setter
    def coupling(self, type):
        if type.upper() == 'DC':
            self._coupling = 'DC'
        else:
            self._coupling = 'AC'

    def cleanup(self):
        self.turn_off()
        self.close()

class PowerMeter(Equipment):
    def __init__(self, address, comm_type='gpib', timeout=10000):
        super().__init__(address, comm_type, timeout)

        self._voltage = 0
        self._current = 0
        self._power = 0
        self._pf = 0
        self._thd = 0
        self._integtime = 0

    def integrate(self):
        self.write('INTEGRATE:RESET')
        self.write('INTEGRATE:MODE NORMAL')
        self.write(f'INTEGRATE:TIMER 0, {self._integtime // 60}, {self._integtime%60} ')
        self.write('INTEGRATE:START')

    def integration_done(self):
        return self.write('INTEGRATE:STATE?') == 'TIM'

    @property
    def integtime(self, integtime):
        return self._integtime
    
    @integtime.setter
    def integtime(self, integtime):
        self._integtime = integtime

    @property
    @reject_nan
    def voltage(self):
        self.write('NUMERIC:ITEM1 U, 1')
        self._voltage = float(self.write('NUM:NORM:VAL? 1'))
        return self._voltage
        
    @property
    @reject_nan
    def current(self):
        self.write('NUMERIC:ITEM2 I, 1')
        self._current = float(self.write('NUM:NORM:VAL? 2'))
        return self._current

    @property
    @reject_nan
    def power(self):
        if self._integtime == 0:
            self.write('NUMERIC:ITEM3 P, 1')
            self._power = float(self.write('NUM:NORM:VAL? 3'))
        else:
            while not self.integration_done:
                sleep(0.5)
            self.write('INTEGRATE:RESET')
            self.write('NUMERIC:ITEM6 WH, 1')
            self._power = float(self.write('NUM:NORM:VAL? 6')) * 3600 / self._integtime        
        return self._power

    @property
    @reject_nan
    def pf(self):
        self.write('NUMERIC:ITEM4 lambda, 1')
        self._pf = float(self.write('NUM:NORM:VAL? 4'))
        return self._pf

    @property
    @reject_nan
    def thd(self):
        self.write('NUMERIC:ITEM5 ITHD, 1')
        self._thd = float(self.write('NUM:NORM:VAL? 5'))
        return self._thd

    def cleanup(self):
        self.close()

class Oscilloscope(Equipment):
    def __init__(self, address, comm_type='lan', timeout=10000):
        super().__init__(address, comm_type, timeout)

        self.write('SYST:DISP:UPD 1')

    def _extract_png(self, raw):
        offset = int(raw[1])-ord('0')
        return raw[offset+2:]

    def get_screenshot(self, filename="default.png", path=os.path.dirname(os.path.realpath(__file__))):
        self.write("HCOP:DEST \'MMEM\'")
        self.write("HCOP:DEV:LANG PNG")
        self.write("HCOP:DEV:INV ON")
        self.write("MMEM:NAME \'C:\\HCOPY.png\'")
        self.write("HCOP:IMMediate; *OPC?")

        self.device.write("MMEM:DATA? \'C:\\HCOPY.png\'")
        raw_image = self.device.read_raw()
        image = self._extract_png(raw_image)

        with open(path + "\\" + filename, "wb") as f:
            f.write(image)

    def get_measure(self, channel=1):
        channel_state = self.write(f'MEAS{channel}:ENAB?')
        if channel_state == '0':
            return None, None
        labels = []
        values = []
        self.write(f'MEAS{channel}:ARN ON')
        for item in self.write(f'MEAS{channel}:ARES?').split(','):
            label, value = item.split(':')
            labels.append(label.strip())
            values.append(value.strip())        

        return labels, values

    def get_measure_all(self):
        result = []
        for i in range(1, 9):
            labels, values = self.get_measure(i)
            result.append({
                "channel": i,
                "labels": labels,
                "values": values
            })
        return result

    def get_vertical(self, channel=1):
        channel_state = self.write(f'CHAN{channel}:STAT?')
        if channel_state == '0':
            return None

        result = {
            "channel": str(channel),
            "scale": self.write(f'CHAN{channel}:SCAL?'),
            "position": self.write(f'CHAN{channel}:POS?'),
            "offset": self.write(f'CHAN{channel}:OFFS?'),
            "coupling": self.write(f'CHAN{channel}:COUP?'),
            "bandwidth": self.write(f'CHAN{channel}:BAND?')
        }
        return result

    def get_horizontal(self):
        result = {
            "scale": self.write('TIM:SCAL?'),
            "position": self.write('TIM:HOR:POS?'),
            "resolution": self.write('ACQ:RES?'),
            "sample rate": self.write('ACQ:SRAT?')
        }
        return result

    def get_cursor(self, channel=1):
        cursor_state = self.write(f'CURS{channel}:STAT?')
        if cursor_state == '0':
            return None

        result = {
            "x1 position": self.write(f'CURS{channel}:X1P?'),
            "x2 position": self.write(f'CURS{channel}:X2P?'),
            "y1 position": self.write(f'CURS{channel}:Y1P?'),
            "y2 position": self.write(f'CURS{channel}:Y2P?'),
            "delta x": self.write(f'CURS{channel}:XDEL?'),
            "delta y": self.write(f'CURS{channel}:YDEL?'),
            "source": self.write(f'CURS{channel}:SOUR?')
        }
        return result

    def run(self):
        self.write('RUN')
        self.write('DISP:TRIG:LIN OFF')

    def run_single(self):
        self.write('RUNS')
        self.write('DISP:TRIG:LIN OFF')

    def stop(self):
        self.write('STOP')
        self.write('DISP:TRIG:LIN OFF')

    # CMC Code Update #################

    def time_scale(self, time_scale):
        self.write(f'TIM:SCAL {time_scale}')
        print('Time Scale: '+ str(time_scale) + ' s/div')
        # Parameters:
        # <TimeScale> Range: 25E-12 to 50
        #             Increment: 1E-12
        #             *RST: 10E-9
        #             Default unit: s/div

    def record_length(self, record_length):
        self.write(f'ACQ:POIN {record_length}')
        print('Record Length: '+ str(record_length) + ' Sa') # 1000 to 1 000 000 000

    def resolution(self, resolution):
        self.write(f'ACQ:RES {resolution}')
        print('Resolution: '+ str(resolution) + ' s') # 1E-15 to 0.5

    def time_position(self, time_position):
        self.write(f'TIM:REF {time_position}')
        self.write('TIM:HOR:POS 0') # setting Pos -> 0s
        print('Position: '+ str(time_position) + '%')

    ### Trigger Settings ###

    def edge_trigger(self, trigger_source, trigger_level, trigger_slope):
        channel = 'CHAN' + str(trigger_source) # 1 | 2 | 3 | 4
        # print(channel)
        self.write(f'TRIG1:SOUR {channel}')
        self.write('TRIG1:TYPE EDGE')
        self.write(f'TRIG1:LEV{trigger_source} {trigger_level}') # range: -10 to 10, increment: 1E-3
        self.write(f'TRIG1:EDGE:SLOP {trigger_slope}') # POS | NEG
        # print(f'trigger level = {trigger_level}')
    
    def init_trigger(self, trigger_source, trigger_level, trigger_slope):
        # Trigger Settings
        self.edge_trigger(trigger_source, trigger_level, trigger_slope)
        self.trigger_mode(mode='NORM')
        self.stop()

    def trigger_level(self, trigger_source, trigger_level):
        self.write(f'TRIG1:LEV{trigger_source} {trigger_level}') # range: -10 to 10, increment: 1E-3
        # print(f'trigger level = {trigger_level}')
    
    def trigger_mode(self, mode):
        self.write(f'TRIG:MODE {mode}') # AUTO | NORMal | FREerun

    def force_trigger(self):
        self.write('TRIG:FORC')

    def trigger_status(self):
        status = self.write('ACQ:CURR?')
        status = int(status)
        return status

    ### Channel Settings ###

    def channel_BW(self, channel, channel_BW):
        channel_state = self.write(f'CHAN{channel}:STAT?')
        if channel_state == '0':
            return None

        if channel_BW == 500:
            channel_BW = 'FULL'
        elif channel_BW == 20:
            channel_BW = 'B20'
        elif channel_BW == 200:
            channel_BW = 'B200'

        self.write(f'CHAN{channel}:BAND {channel_BW}')
        # print('CH' + str(channel) + ' BW: ' + f'{channel_BW}' + ' MHz')
        print('BW: ' + f'{channel_BW}' + ' MHz')

    def channel_position(self, channel, channel_position):
        channel_state = self.write(f'CHAN{channel}:STAT?')
        if channel_state == '0':
            return None

        self.write(f'CHAN{channel}:POS {channel_position}')

        # print('CH' + str(channel) + ' Position: ' + f'{channel_position} div.')
        print('Position: ' + f'{channel_position} div.')

    def channel_offset(self, channel, channel_offset):
        channel_state = self.write(f'CHAN{channel}:STAT?')
        if channel_state == '0':
            return None

        self.write(f'CHAN{channel}:OFFS {channel_offset}')

        # print('CH' + str(channel) + ' Offset: ' + f'{channel_offset} V')
        print('Offset: ' + f'{channel_offset} V')

    def channel_coupling(self, channel, channel_coupling):
        channel_state = self.write(f'CHAN{channel}:STAT?')
        if channel_state == '0':
            return None

        self.write(f'CHAN{channel}:COUP {channel_coupling}') # DC | DCLimit | AC

        # print('CH' + str(channel) + ' Coupling: ' + f'{channel_coupling}')
        print('Coupling: ' + f'{channel_coupling}')

    def display_intensity(self, intensity):
        self.write(f'DISP:INT {intensity}') # 0 to 100%

    def channel_scale(self, channel, channel_scale):
        channel_state = self.write(f'CHAN{channel}:STAT?')
        if channel_state == '0':
            return None

        self.write(f'CHAN{channel}:SCAL {channel_scale}') # V/div

        # print('CH' + str(channel) + ' Scale: ' + f'{channel_scale} V/div.')
        print('Scale: ' + f'{channel_scale} V/div.')


    ################################

    def _extract_channel_data(self, channel, raw):
        scale = self.channel[channel].scale
        position = self.channel[channel].position
        offset = self.channel[channel].offset
        factor = scale * 10 / (253 * 256)
        border = self.conn.read("FORM:BORD?").strip()

        num_digits = raw[1] - 48
        num_values = int(raw[2 : 2 + num_digits])
        data = raw[2 + num_digits : 2 + num_digits + num_values]
        if border == "LSBF":
            adc = np.array(
                [
                    int.from_bytes(data[i : i + 2], "little")
                    for i in range(0, len(data), 2)
                ],
                dtype=np.int16,
            )
        else:
            adc = np.array(
                [
                    int.from_bytes(data[i : i + 2], "big")
                    for i in range(0, len(data), 2)
                ],
                dtype=np.int16,
            )
        channel_data = adc * factor - scale * position + offset
        return channel_data

    def save_channel_data(self, channel=1):
        # self.write("EXPort:WAVeform:MULTIchannel ON")
        self.write("EXP:WAV:MULTI ON")
        self.write("EXP:WAV:INCX OFF")
        for i in range(1, 5):
            if i == channel:
                # self.write(f"CHANnel{i}:EXPortstate ON")
                self.write(f"CHAN{i}:EXP ON")
            else:
                # self.write(f"CHANnel{i}:EXPortstate OFF")
                self.write(f"CHAN{i}:EXP OFF")
        self.write("FORM:DATA INT,16")
        # self.write('FORM INT,16;:CHAN1:DATA?')
        # self.write("FORM ASC")
        sleep(2)
        print(f"CHAN{channel}:WAV1:DATA?")
        self.write(f"CHAN{channel}:WAV1:DATA?")

        raw_data = self.device.read_raw()
        return self._extract_channel_data(channel, raw_data)
    
    def get_chan_data(self, channel=1):
        self.write('FORM ASC')
        self.write('EXP:WAV:INCX OFF')
        temp = self.write(f'CHAN{channel}:WAV1:DATA?') # type: string
        temp = list(temp.split(",")) # type: list
        data = []
        for h in temp:
            data.append(float(h))
        return data
    
    def cursor(self, channel=1, cursor_set=1, X1= 1, X2 = 1):
        self.write(f"CURS{cursor_set}:STAT ON")
        self.write(f"CURS{cursor_set}:SOUR C{channel}W1")
        self.write(f"CURS{cursor_set}:X1P {X1}")
        self.write(f"CURS{cursor_set}:X2P {X2}")


    def cleanup(self):
        self.close()

class ElectronicLoad(Equipment):
    def __init__(self, address, comm_type='gpib', timeout=10000):
        super().__init__(address, comm_type, timeout)
        self.channel = [None] + [self.Channel(self, i) for i in range(1, 9)]

    def turn_on_all(self):
        for i in range(1, 9):
            self.channel[i].turn_on()

    def turn_off_all(self):
        for i in range(1, 9):
            self.channel[i].turn_off()

    def cleanup(self):
        self.turn_off_all()
        self.close()

    class Channel:
        def __init__(self, load, channel):
            self.load = load
            self.channel = channel
            self._cv = 0
            self._cc = 0
            self._cr = 0
            self._led = 0
            self._voltage = 0
            self._current = 0

        def dynamic(self, low=0, high=1, ton=0.0005, toff=0.0005): 
            self.load.write(f'CHAN {self.channel}')     
            self.load.write(f'CURR:DYN:L1 {low}')
            self.load.write(f'CURR:DYN:L2 {high}')
            self.load.write(f'CURR:DYN:RISE MAX')
            self.load.write(f'CURR:DYN:FALL MAX')
            self.load.write(f'CURR:DYN:T1 {ton}')
            self.load.write(f'CURR:DYN:T2 {toff}')

        @property
        def voltage(self):
            self.load.write(f'CHAN {self.channel}')
            self._voltage = float(self.load.write('FETC:VOLT?'))
            return self._voltage

        @property
        def current(self):
            self.load.write(f'CHAN {self.channel}')
            self._current = float(self.load.write('FETC:CURR?'))
            return self._current        

        @property
        def cv(self):
            return self._cv

        @property
        def cc(self):
            return self._cc

        @property
        def cr(self):
            return self._cr

        @property
        def led(self):
            return self._led

        @cv.setter
        def cv(self, voltage):
            self._cv = voltage
            self.load.write(f'CHAN {self.channel}')
            self.load.write(f'VOLTAGE:L1 {self._cv}')
            self.load.write('MODE CV')

        @cc.setter
        def cc(self, current):
            self._cc = current
            self.load.write(f'CHAN {self.channel}')
            self.load.write(f'CURRENT:STATIC:L1 {self._cc}')
            self.load.write('MODE CC')

        @cr.setter
        def cr(self, resistance):
            self._cr = resistance
            self.load.write(f'CHAN {self.channel}')
            self.load.write(f'RESISTANCE:L1 {self._cr}')
            self.load.write('MODE CR')

        @led.setter
        def led(self, current):
            self._led = current
            # not supported yet...

        def turn_on(self):
            self.load.write(f'CHAN {self.channel}')
            self.load.write('LOAD ON')

        def turn_off(self):
            self.load.write(f'CHAN {self.channel}')
            self.load.write('LOAD OFF')

        def short_on(self):
            self.load.write(f'CHAN {self.channel}')
            self.load.write('LOAD:SHOR ON')

        def short_off(self):
            self.load.write(f'CHAN {self.channel}')
            self.load.write('LOAD:SHOR OFF')
                    
class DCSource(Equipment):
    def __init__(self, address, comm_type='usb', timeout=10000):
        super().__init__(address, comm_type, timeout)

        self._voltage = 0
        self._current = 0
        self._cv = 0
        self._cc = 0

    def turn_on(self):
        self.write('CONF:OUTP ON')

    def turn_off(self):
        self.write('CONF:OUTP OFF')

    @property
    def voltage(self):
        self._voltage = self.write('MEAS:VOLT?')
        return self._voltage

    @property
    def current(self):
        self._current = self.write('MEAS:CURR?')
        return self._current

    @property
    def cv(self):
        return self._cv

    @property
    def cc(self):
        return self._cc

    @cv.setter
    def cv(self, cv):
        self._cv = cv
        self.write(f'VOLT {self._cv}')

    @cc.setter
    def cc(self, cc):
        self._cc = cc
        self.write(f'CURR {self._cc}')

    def cleanup(self):
        self.turn_off()
        self.close()

class SignalGenerator(Equipment):
    def __init__(self, address, comm_type='usb', timeout=10000):
        super().__init__(address, comm_type, timeout)

    def cleanup(self):
        self.close()

class Arduino(Equipment):
    def __init__(self, address, comm_type='serial', timeout=10000):
        super().__init__(address, comm_type, timeout)


    def cleanup(self):
        self.close()

class EMI(Equipment):
    def __init__(self, address, comm_type='lan', timeout=10000):
        super().__init__(address, comm_type, timeout)

    def cleanup(self):
        self.close()





def truncate(f, n):
    '''Truncates/pads a float f to n decimal places without rounding'''
    s = '{}'.format(f)
    if 'e' in s or 'E' in s:
        return '{0:.{1}f}'.format(f, n)
    i, p, d = s.partition('.')
    return '.'.join([i, (d+'0'*n)[:n]])





from time import sleep, time
import os


# initialize variables
global Iout_index
global waveform_counter
global start
global waveforms_folder
waveform_counter = 0
Iout_index = 0

def headers(test_name):
    global start

    print()
    print("="*80)
    print(f"Test: {test_name}")

    create_folder(test_name)
    start = time()
    print("="*80)
    print()

def create_folder(test_name):
    # creating folder for the saved waveforms
    waveforms_folder = f'waveforms/{test_name}'
    pathname = f"{os.getcwd()}\{waveforms_folder}"
    isExist = os.path.exists(pathname)

    if isExist == False:
        os.mkdir(pathname)
        print(f"{waveforms_folder} created.")
    else:
        print(f"{waveforms_folder} folder already exists.")

def footers(waveform_counter):

    print("="*80)
    print(f'{waveform_counter} waveforms captured.')
    print('test complete.')
    print()
    end = time()
    total_time = end-start
    print(f'test time: {total_time:.2f} secs. / {total_time/60:.2f} mins.')
    # print("_"*80)
    print("="*80)

def soak(soak_time):
    for seconds in range(soak_time, 0, -1):
        sleep(1)
        print(f"{seconds:5d}s", end="\r")
    print("       ", end="\r")


if __name__ == '__main__':
    pass
